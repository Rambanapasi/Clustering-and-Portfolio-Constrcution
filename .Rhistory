#
#   ),
#   locations = cells_row_groups())
tab %>%
tab_options(data_row.padding = px(4),table.width = pct(100),
column_labels.font.size = pct(50),
column_labels.vlines.width = 1, table.font.size = pct(80)) %>%
tab_options(data_row.padding = px(6),
column_labels.font.size = pct(100)) %>%
tab_style(style = cell_text(weight = 1200, align = 'left'),locations = cells_title(groups = 'title')) %>%
tab_style(style = cell_text(color = 'darkgrey', transform = 'uppercase', align = 'center'),
locations = cells_column_labels(everything()))
# Assuming start_dates is a vector of unique start dates
# select a year to base your clusters from, this will help with the explaing what each cluster means
filtered_dates <- clusteringdata %>%
group_by(YM, stock) %>%
filter(date == last(date)) %>%
ungroup() %>%
group_by(stock) %>%
mutate(rtn = px/lag(px)-1) %>%
filter(date >= ymd(20150101) - years(1))
momentum <- filtered_dates %>%
mutate(rtn = coalesce(rtn, 0), roi = cumprod(1+rtn)) %>%
filter(date == last(date)) %>%
select(date, roi, stock) %>%
ungroup() %>%
mutate(momentum = rank(roi)/length(roi)*100) %>%
select(-roi, -date)
vol <- filtered_dates %>%
mutate(rtn = coalesce(rtn, 0)) %>%
summarise(sd = sd(rtn)) %>%
mutate(volatility = rank(sd)/length(sd)*100) %>%
select(-sd)
ranking.df <- left_join(momentum, vol)
ranking.df
clusteringdata <- clusteringdata %>% filter(date <= ymd(20231231))
# to avoid null datasets, filter out 2024
clusteringdata <- clusteringdata %>% filter(date <= ymd(20231231))
start_date <- clusteringdata %>% filter(date <= ymd(20231231)) %>% select(date) %>% filter(date == first(date)) %>% distinct() %>% pull()
# define the investment horizon periods for the data frame, this will be crucial for the backtesting
investment_horizon_dfs <- list()
for (start_date in unique(start_date)) {
end_date <- start_date + years(1) - days(1)  # One investment horizon
df <- clusteringdata %>%
filter(date >= start_date) %>%
arrange(date) %>% select( -Company, -Sector, -YM) %>%
group_by(stock) %>%
mutate(rtn = px/lag(px)-1) %>% slice(-1)
investment_horizon_dfs[[as.character(start_date)]] <- df
}
investment_horizon_dfs
# cluster create the cluster list
# Extract stock names
names <- ranking.df %>% select(stock)
# Extract and prepare data for clustering
cluster_data <- ranking.df %>% ungroup() %>% select(-stock)
rownames(cluster_data) <- as.character(names$stock)
# Determine the optimal number of clusters using silhouette method
a <- fviz_nbclust(cluster_data, kmeans, method = "silhouette")
silhouette <- a$data %>% tibble()
silhouette$clusters <- as.numeric(silhouette$clusters)
value <- silhouette %>% filter(y == max(y)) %>% select(clusters) %>% pull()
# Perform k-means clustering
km_res <- kmeans(cluster_data, value, nstart = 1000, algorithm = "Lloyd")
clusters.names <- data.frame(
stock = names$stock,
clusters = km_res$cluster )
# portfolio list
# Merge corresponding clusters with investment_horizon_dfs
cluster_portfolio <- lapply(1:length(investment_horizon_dfs), function(i) {
# Merge based on the "stock" column
merged_df <- merge(investment_horizon_dfs[[i]], clusters.names, by = "stock")
})
# define our rebalance months
# at the rebalancing date you want to take the top n of each clusters and reweight.
df <- cluster_portfolio[[1]]
df <- df %>% as.tibble()
Rebalance_Days <- df %>%
mutate(Year = format(date, "%Y"), Month = format(date, "%b"), YM = format(date, "%y %b")) %>%
filter(Month %in% c("Mar", "Jun", "Sep", "Dec")) %>%
select(date, Year,  Month, YM ) %>% unique() %>%
group_by(YM) %>%
filter(date == last(date)) %>%
filter( date == last(date)) %>%
pull(date)
# now for gettiing the top 3 stock in each cluster that way we have a a single capping objective
rebalance_col <-
df %>%
filter(date %in% Rebalance_Days) %>%
# Now we have to distinguish rebalances - to create something to group by:
mutate(RebalanceTime = format(date, "%Y%B")) %>%
# Now we can group...
group_by(RebalanceTime, clusters) %>% summarise(date = date, stock,  weight = vol/sum(vol) ) %>% filter(!is.na(weight)) %>%
# Now trim down to 30 stocks and reweight so sum(w)=1
arrange(desc(weight)) %>%
top_n(3, weight) %>%
mutate(weight = weight/sum(weight)) %>%
ungroup() %>%
arrange(date)
# now lets cap each at 30%
rebalance_col
Capped <- rebalance_col %>%
# Split our df into groups (where the groups here are the rebalance dates:
group_split(RebalanceTime, clusters) %>%
# Apply the function Proportional_Cap_Foo to each rebalancing date:
map_df(~Proportional_Cap_Foo(., W_Cap = 0.35) ) %>% select(-RebalanceTime)
# Check
#
# Capped %>% pull(weight) %>% max(.)
wts <- Capped
Returns <- df
perfromance_raw <- left_join(wts, Returns, c("stock", "date", "clusters"))
cluster_perfromance_data <- perfromance_raw %>%
group_by(clusters, date) %>%
mutate(cluster_return = weight * rtn) %>%
summarise(cluster_return = sum(cluster_return, na.rm = TRUE)) %>%
arrange(date)
# Create an empty list to store the final cluster performance data
cluster_performance_list <- list()
for (i in seq_along(cluster_portfolio)) {
df <- cluster_portfolio[[i]] %>% as.tibble()
# ... (rest of your code for Rebalance_Days and rebalance_col) ...
# Apply the Proportional_Cap_Foo function to each rebalancing date
Capped <- rebalance_col %>%
group_split(RebalanceTime, clusters) %>%
map_df(~Proportional_Cap_Foo(., W_Cap = 0.4)) %>%
select(-RebalanceTime)
# Merge weights with returns
wts <- Capped
Returns <- df
performance <- left_join(wts, Returns, c("stock", "date", "clusters"))
# Calculate cluster returns
cluster_performance_data <- performance %>%
group_by(clusters, date) %>%
mutate(cluster_return = weight * rtn) %>%
summarise(cluster_return = sum(cluster_return, na.rm = TRUE)) %>%
mutate(cluster_return = ifelse(cluster_return == 0, NA, cluster_return)) %>%
filter(!is.na(cluster_return)) %>%
group_by(clusters) %>%
summarize(
N = n(),
mu = ifelse(N <= 4, prod(1 + cluster_return), prod(1 + cluster_return) ^ (12 / N) - 1),
annualized_sd = sd(cluster_return) * sqrt(4),
sharpe_ratio = mu / annualized_sd
) %>%
select(clusters, sharpe_ratio, N)
# Store the result in the list
cluster_performance_list[[i]] <- cluster_performance_data
}
result <- foreach(df = cluster_performance_list, .combine = rbind) %dopar% {
df
}
p_load("tidyquant", "fmxdat", "tidyverse", "PerformanceAnalytics", "lubridate", "DEoptim", "data.table", "covFcatorModel", "gt", "factoextra", "foreach")
wts <- Capped
Returns <- df
perfromance_raw <- left_join(wts, Returns, c("stock", "date", "clusters"))
cluster_perfromance_data <- perfromance_raw %>%
group_by(clusters, date) %>%
mutate(cluster_return = weight * rtn) %>%
summarise(cluster_return = sum(cluster_return, na.rm = TRUE)) %>%
arrange(date)
# Create an empty list to store the final cluster performance data
cluster_performance_list <- list()
for (i in seq_along(cluster_portfolio)) {
df <- cluster_portfolio[[i]] %>% as.tibble()
# ... (rest of your code for Rebalance_Days and rebalance_col) ...
# Apply the Proportional_Cap_Foo function to each rebalancing date
Capped <- rebalance_col %>%
group_split(RebalanceTime, clusters) %>%
map_df(~Proportional_Cap_Foo(., W_Cap = 0.4)) %>%
select(-RebalanceTime)
# Merge weights with returns
wts <- Capped
Returns <- df
performance <- left_join(wts, Returns, c("stock", "date", "clusters"))
# Calculate cluster returns
cluster_performance_data <- performance %>%
group_by(clusters, date) %>%
mutate(cluster_return = weight * rtn) %>%
summarise(cluster_return = sum(cluster_return, na.rm = TRUE)) %>%
mutate(cluster_return = ifelse(cluster_return == 0, NA, cluster_return)) %>%
filter(!is.na(cluster_return)) %>%
group_by(clusters) %>%
summarize(
N = n(),
mu = ifelse(N <= 4, prod(1 + cluster_return), prod(1 + cluster_return) ^ (12 / N) - 1),
annualized_sd = sd(cluster_return) * sqrt(4),
sharpe_ratio = mu / annualized_sd
) %>%
select(clusters, sharpe_ratio, N)
# Store the result in the list
cluster_performance_list[[i]] <- cluster_performance_data
}
result <- foreach(df = cluster_performance_list, .combine = rbind) %dopar% {
df
}
result %>%
ggplot(aes(x = N, y = sharpe_ratio)) +
geom_point() +
facet_grid(~clusters) +
labs(title = "Risk Adjusted Performance as Investment Horizon Increases",
subtitle = " 3 Constituents Per Cluster",
x = "Quarters",
y = "Sharpe Ratio") +
fmxdat::theme_fmx()
wts <- Capped
Returns <- cluster.merging
perfromance_raw <- left_join(wts, Returns, c("stock", "date", "clusters"))
cluster.merging
Returns <- cluster.merging %>%  rename(clusters = cluster)
wts <- Capped
Returns <- cluster.merging %>%  rename(clusters = cluster)
perfromance_raw <- left_join(wts, Returns, c("stock", "date", "clusters"))
cluster_perfromance_data <- perfromance_raw %>%
group_by(clusters, date) %>%
mutate(cluster_return = weight * rtn) %>%
summarise(cluster_return = sum(cluster_return, na.rm = TRUE)) %>%
arrange(date)
wts <- Capped
Returns <- cluster.merging %>%  rename(clusters = cluster)
perfromance_raw <- left_join(wts, Returns, c("stock", "date", "clusters"))
cluster_perfromance_data <- perfromance_raw %>%
group_by(clusters, date) %>%
mutate(cluster_return = weight * rtn) %>%
summarise(cluster_return = sum(cluster_return, na.rm = TRUE)) %>%
arrange(date)
cluster.merging
wts <- Capped
Returns <- df %>% select(clusters, stock, rtn)
perfromance_raw <- left_join(wts, Returns, c("stock", "date", "clusters"))
wts <- Capped
Returns <- df %>% select(date, clusters, stock, rtn)
perfromance_raw <- left_join(wts, Returns, c("stock", "date", "clusters"))
cluster_perfromance_data <- perfromance_raw %>%
group_by(clusters, date) %>%
mutate(cluster_return = weight * rtn) %>%
summarise(cluster_return = sum(cluster_return, na.rm = TRUE)) %>%
arrange(date)
# Create an empty list to store the final cluster performance data
cluster_performance_list <- list()
for (i in seq_along(cluster_portfolio)) {
df <- cluster_portfolio[[i]] %>% as.tibble()
# ... (rest of your code for Rebalance_Days and rebalance_col) ...
# Apply the Proportional_Cap_Foo function to each rebalancing date
Capped <- rebalance_col %>%
group_split(RebalanceTime, clusters) %>%
map_df(~Proportional_Cap_Foo(., W_Cap = 0.4)) %>%
select(-RebalanceTime)
# Merge weights with returns
wts <- Capped
Returns <- df
performance <- left_join(wts, Returns, c("stock", "date", "clusters"))
# Calculate cluster returns
cluster_performance_data <- performance %>%
group_by(clusters, date) %>%
mutate(cluster_return = weight * rtn) %>%
summarise(cluster_return = sum(cluster_return, na.rm = TRUE)) %>%
mutate(cluster_return = ifelse(cluster_return == 0, NA, cluster_return)) %>%
filter(!is.na(cluster_return)) %>%
group_by(clusters) %>%
summarize(
N = n(),
mu = ifelse(N <= 4, prod(1 + cluster_return), prod(1 + cluster_return) ^ (12 / N) - 1),
annualized_sd = sd(cluster_return) * sqrt(4),
sharpe_ratio = mu / annualized_sd
) %>%
select(clusters, sharpe_ratio, N)
# Store the result in the list
cluster_performance_list[[i]] <- cluster_performance_data
}
result <- foreach(df = cluster_performance_list, .combine = rbind) %dopar% {
df
}
result %>%
ggplot(aes(x = N, y = sharpe_ratio)) +
geom_point() +
facet_grid(~clusters) +
labs(title = "Risk Adjusted Performance as Investment Horizon Increases",
subtitle = " 3 Constituents Per Cluster",
x = "Quarters",
y = "Sharpe Ratio") +
fmxdat::theme_fmx()
Capped
df
df %>% select(date, clusters, stock, rtn)
Capped
select(date, clusters, stock, rtn)
Returns <- df %>% select(date, clusters, stock, rtn)
Capped
df
left_join(wts, Returns, c("stock", "date", "clusters"))
# define our rebalance months
# at the rebalancing date you want to take the top n of each clusters and reweight.
df <- cluster_portfolio[[1]]
df <- df %>% as.tibble()
Rebalance_Days <- df %>%
mutate(Year = format(date, "%Y"), Month = format(date, "%b"), YM = format(date, "%y %b")) %>%
filter(Month %in% c("Mar", "Jun", "Sep", "Dec")) %>%
select(date, Year,  Month, YM ) %>% unique() %>%
group_by(YM) %>%
filter(date == last(date)) %>%
filter( date == last(date)) %>%
pull(date)
# now for gettiing the top 3 stock in each cluster that way we have a a single capping objective
rebalance_col <-
df %>%
filter(date %in% Rebalance_Days) %>%
mutate(RebalanceTime = format(date, "%Y%B")) %>%
group_by(RebalanceTime, clusters) %>% summarise(date = date, stock,  weight = vol/sum(vol) ) %>% filter(!is.na(weight)) %>%
arrange(desc(weight)) %>%
top_n(5, weight) %>%
mutate(weight = weight/sum(weight)) %>%
ungroup() %>%
arrange(date)
# now lets cap each at 30%
rebalance_col
Capped <- rebalance_col %>%
# Split our df into groups (where the groups here are the rebalance dates:
group_split(RebalanceTime, clusters) %>%
# Apply the function Proportional_Cap_Foo to each rebalancing date:
map_df(~Proportional_Cap_Foo(., W_Cap = 0.35) ) %>% select(-RebalanceTime)
# Capped %>% pull(weight) %>% max(.)
wts <- Capped
Returns <- df
perfromance_raw <- left_join(wts, Returns, c("stock", "date", "clusters"))
cluster_perfromance_data <- perfromance_raw %>%
group_by(clusters, date) %>%
mutate(cluster_return = weight * rtn) %>%
summarise(cluster_return = sum(cluster_return, na.rm = TRUE)) %>%
arrange(date)
cluster_performance_list = list()
for (i in seq_along(cluster_portfolio)) {
df <- cluster_portfolio[[i]] %>% as.tibble()
# ... (rest of your code for Rebalance_Days and rebalance_col) ...
# Apply the Proportional_Cap_Foo function to each rebalancing date
Capped <- rebalance_col %>%
group_split(RebalanceTime, clusters) %>%
map_df(~Proportional_Cap_Foo(., W_Cap = 0.4)) %>%
select(-RebalanceTime)
# Merge weights with returns
wts <- Capped
Returns <- df
performance <- left_join(wts, Returns, c("stock", "date", "clusters"))
# Calculate cluster returns
cluster_performance_data <- performance %>%
group_by(clusters, date) %>%
mutate(cluster_return = weight * rtn) %>%
summarise(cluster_return = sum(cluster_return, na.rm = TRUE)) %>%
mutate(cluster_return = ifelse(cluster_return == 0, NA, cluster_return)) %>%
filter(!is.na(cluster_return)) %>%
group_by(clusters) %>%
summarize(
N = n(),
mu = ifelse(N <= 4, prod(1 + cluster_return), prod(1 + cluster_return) ^ (12 / N) - 1),
annualized_sd = sd(cluster_return) * sqrt(4),
sharpe_ratio = mu / annualized_sd
) %>%
select(clusters, sharpe_ratio, N)
# Store the result in the list
cluster_performance_list[[i]] <- cluster_performance_data
}
result <- foreach(df = cluster_performance_list, .combine = rbind) %dopar% {
df
}
result %>%
ggplot(aes(x = N, y = sharpe_ratio)) +
geom_point() +
facet_grid(~clusters) +
labs(title = "Risk Adjusted Performance as Investment Horizon Increases",
subtitle = " 3 Constituents Per Cluster",
x = "Quarters",
y = "Sharpe Ratio") +
fmxdat::theme_fmx()
investment_horizon_dfs
start_date
clusteringdata
# to avoid null datasets, filter out 2024
clusteringdata <- clusteringdata %>% filter(date <= ymd(20231231))
start_date <- clusteringdata %>% mutate(Y = format(date, "%y")) %>% group_by(Y) %>%  filter(date <= ymd(20231231)) %>% select(date) %>% filter(date == first(date)) %>% distinct() %>% pull()
# define the investment horizon periods for the data frame, this will be crucial for the backtesting
investment_horizon_dfs <- list()
for (start_date in unique(start_date)) {
end_date <- start_date + years(1) - days(1)  # One investment horizon
df <- clusteringdata %>%
filter(date >= start_date) %>%
arrange(date) %>% select( -Company, -Sector, -YM) %>%
group_by(stock) %>%
mutate(rtn = px/lag(px)-1) %>% slice(-1)
investment_horizon_dfs[[as.character(start_date)]] <- df
}
investment_horizon_dfs
# cluster create the cluster list
# Extract stock names
names <- ranking.df %>% select(stock)
# Extract and prepare data for clustering
cluster_data <- ranking.df %>% ungroup() %>% select(-stock)
rownames(cluster_data) <- as.character(names$stock)
# Determine the optimal number of clusters using silhouette method
a <- fviz_nbclust(cluster_data, kmeans, method = "silhouette")
silhouette <- a$data %>% tibble()
silhouette$clusters <- as.numeric(silhouette$clusters)
value <- silhouette %>% filter(y == max(y)) %>% select(clusters) %>% pull()
# Perform k-means clustering
km_res <- kmeans(cluster_data, value, nstart = 1000, algorithm = "Lloyd")
clusters.names <- data.frame(
stock = names$stock,
clusters = km_res$cluster )
# portfolio list
# Merge corresponding clusters with investment_horizon_dfs
cluster_portfolio <- lapply(1:length(investment_horizon_dfs), function(i) {
# Merge based on the "stock" column
merged_df <- merge(investment_horizon_dfs[[i]], clusters.names, by = "stock")
})
# define our rebalance months
# at the rebalancing date you want to take the top n of each clusters and reweight.
df <- cluster_portfolio[[1]]
df <- df %>% as.tibble()
Rebalance_Days <- df %>%
mutate(Year = format(date, "%Y"), Month = format(date, "%b"), YM = format(date, "%y %b")) %>%
filter(Month %in% c("Mar", "Jun", "Sep", "Dec")) %>%
select(date, Year,  Month, YM ) %>% unique() %>%
group_by(YM) %>%
filter(date == last(date)) %>%
filter( date == last(date)) %>%
pull(date)
# now for gettiing the top 3 stock in each cluster that way we have a a single capping objective
rebalance_col <-
df %>%
filter(date %in% Rebalance_Days) %>%
mutate(RebalanceTime = format(date, "%Y%B")) %>%
group_by(RebalanceTime, clusters) %>% summarise(date = date, stock,  weight = vol/sum(vol) ) %>% filter(!is.na(weight)) %>%
arrange(desc(weight)) %>%
top_n(5, weight) %>%
mutate(weight = weight/sum(weight)) %>%
ungroup() %>%
arrange(date)
# now lets cap each at 30%
rebalance_col
Capped <- rebalance_col %>%
# Split our df into groups (where the groups here are the rebalance dates:
group_split(RebalanceTime, clusters) %>%
# Apply the function Proportional_Cap_Foo to each rebalancing date:
map_df(~Proportional_Cap_Foo(., W_Cap = 0.35) ) %>% select(-RebalanceTime)
# Capped %>% pull(weight) %>% max(.)
wts <- Capped
Returns <- df
perfromance_raw <- left_join(wts, Returns, c("stock", "date", "clusters"))
cluster_perfromance_data <- perfromance_raw %>%
group_by(clusters, date) %>%
mutate(cluster_return = weight * rtn) %>%
summarise(cluster_return = sum(cluster_return, na.rm = TRUE)) %>%
arrange(date)
cluster_performance_list = list()
for (i in seq_along(cluster_portfolio)) {
df <- cluster_portfolio[[i]] %>% as.tibble()
# ... (rest of your code for Rebalance_Days and rebalance_col) ...
# Apply the Proportional_Cap_Foo function to each rebalancing date
Capped <- rebalance_col %>%
group_split(RebalanceTime, clusters) %>%
map_df(~Proportional_Cap_Foo(., W_Cap = 0.4)) %>%
select(-RebalanceTime)
# Merge weights with returns
wts <- Capped
Returns <- df
performance <- left_join(wts, Returns, c("stock", "date", "clusters"))
# Calculate cluster returns
cluster_performance_data <- performance %>%
group_by(clusters, date) %>%
mutate(cluster_return = weight * rtn) %>%
summarise(cluster_return = sum(cluster_return, na.rm = TRUE)) %>%
mutate(cluster_return = ifelse(cluster_return == 0, NA, cluster_return)) %>%
filter(!is.na(cluster_return)) %>%
group_by(clusters) %>%
summarize(
N = n(),
mu = ifelse(N <= 4, prod(1 + cluster_return), prod(1 + cluster_return) ^ (12 / N) - 1),
annualized_sd = sd(cluster_return) * sqrt(4),
sharpe_ratio = mu / annualized_sd
) %>%
select(clusters, sharpe_ratio, N)
# Store the result in the list
cluster_performance_list[[i]] <- cluster_performance_data
}
result <- foreach(df = cluster_performance_list, .combine = rbind) %dopar% {
df
}
result %>%
ggplot(aes(x = N, y = sharpe_ratio)) +
geom_point() +
facet_grid(~clusters) +
labs(title = "Risk Adjusted Performance as Investment Horizon Increases",
subtitle = " 3 Constituents Per Cluster",
x = "Quarters",
y = "Sharpe Ratio") +
fmxdat::theme_fmx()
# Creating a data frame with stock names and their assigned clusters
clusters.names <- data.frame(
stock = cluster_data$names$stock,
clusters = km_res$cluster
)
km_res <- kmeans(cluster_data, value, nstart = 1000, algorithm = "Lloyd")
clusters.names <- data.frame(
stock = names$stock,
clusters = km_res$cluster )
# Assuming 'value' is the variable you used for clustering
km_res <- kmeans(cluster_data$value, nstart = 1000, algorithm = "Lloyd")
cluster_perfromance_data
cluster_portfolio
merged_df
cluster_portfolio
all_funds
cluster.merging
